<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>삼투 현상 애니메이션</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0; /* 연한 회색 배경 */
            font-family: 'Inter', sans-serif; /* Tailwind 기본 폰트 */
            flex-direction: column; /* 세로 정렬 */
            padding: 20px;
            box-sizing: border-box;
        }
        #animationContainer {
            position: relative; /* 자식 요소의 position: absolute 기준 */
            width: 90%; /* 너비 조정 */
            max-width: 800px; /* 최대 너비 설정 */
            aspect-ratio: 2 / 1; /* 가로 세로 비율 */
            background-color: #e0f2fe; /* 하늘색 배경 */
            border: 2px solid #0ea5e9; /* 파란색 테두리 */
            border-radius: 1rem; /* 둥근 모서리 */
            overflow: hidden; /* 캔버스 밖으로 나가는 요소 숨김 */
            margin-bottom: 1rem; /* 컨트롤 버튼과의 간격 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 그림자 효과 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 1rem; /* 컨테이너와 동일하게 둥근 모서리 */
        }
        .controls {
            display: flex;
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 허용 */
            justify-content: center; /* 가운데 정렬 */
            align-items: center; /* 수직 가운데 정렬 */
            gap: 0.5rem; /* 요소 사이 간격 */
            margin-top: 1rem; /* 캔버스와의 간격 */
        }
        .controls button {
            padding: 0.5rem 1rem; /* 버튼 패딩 */
            font-size: 0.875rem; /* 글자 크기 */
            font-weight: 500; /* 글자 굵기 */
            color: white; /* 글자색 */
            background-color: #0ea5e9; /* 파란색 배경 */
            border: none; /* 테두리 없음 */
            border-radius: 0.5rem; /* 둥근 모서리 */
            cursor: pointer; /* 마우스 커서 변경 */
            transition: background-color 0.2s; /* 부드러운 색상 전환 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* 버튼 그림자 */
        }
        .controls button:hover {
            background-color: #0284c7; /* 호버 시 진한 파란색 */
        }
        .controls button:disabled {
            background-color: #9ca3af; /* 비활성화 시 회색 */
            cursor: not-allowed;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem; /* 다른 컨트롤과 간격 */
        }
        .speed-control label {
            font-size: 0.875rem;
            color: #374151; /* 어두운 회색 글자 */
        }
        .speed-control input[type="range"] {
            width: 100px; /* 슬라이더 너비 */
            cursor: pointer;
        }
        .speed-control span {
            font-size: 0.875rem;
            color: #374151;
            min-width: 30px; /* 속도 표시 공간 확보 */
            text-align: right;
        }
         /* 메시지 박스 스타일 */
        #messageBox {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none; /* 초기에는 숨김 */
            z-index: 10;
        }
    </style>
</head>
<body>
    <h1 class="text-2xl font-bold mb-4 text-gray-800">삼투 현상 시뮬레이션</h1>
    <div id="animationContainer">
        <canvas id="osmosisCanvas"></canvas>
         <div id="messageBox">메시지 표시 영역</div>
    </div>
    <div class="controls">
        <button id="startButton">시작</button>
        <button id="pauseButton" disabled>일시정지</button>
        <button id="resetButton">초기화</button>
        <div class="speed-control">
            <label for="speedSlider">속도:</label>
            <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
            <span id="speedValue">1.0x</span>
        </div>
    </div>

    <script>
        // --- 설정값 ---
        const WATER_COLOR = '#3b82f6'; // 물 분자 색 (파란색)
        const SOLUTE_COLOR = '#ef4444'; // 용질 분자 색 (빨간색)
        const MEMBRANE_COLOR = '#4b5563'; // 반투과성 막 색 (회색)
        const WATER_RADIUS = 4; // 물 분자 반지름
        const SOLUTE_RADIUS = 8; // 용질 분자 반지름
        const INITIAL_WATER_LEFT = 80; // 초기 왼쪽 물 분자 수
        const INITIAL_SOLUTE_LEFT = 5; // 초기 왼쪽 용질 분자 수
        const INITIAL_WATER_RIGHT = 40; // 초기 오른쪽 물 분자 수
        const INITIAL_SOLUTE_RIGHT = 20; // 초기 오른쪽 용질 분자 수
        const MEMBRANE_PORE_SIZE = WATER_RADIUS * 2.5; // 막 구멍 크기 (물 분자만 통과 가능)
        const MEMBRANE_THICKNESS = 10; // 막 두께
        const PORE_SPACING = 30; // 막 구멍 간격
        const BASE_PARTICLE_SPEED = 0.8; // 분자 기본 이동 속도
        const COLLISION_BUFFER = 1; // 충돌 후 위치 보정값

        // --- 전역 변수 ---
        const canvas = document.getElementById('osmosisCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('animationContainer');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const resetButton = document.getElementById('resetButton');
        const speedSlider = document.getElementById('speedSlider'); // 속도 슬라이더
        const speedValueSpan = document.getElementById('speedValue'); // 속도 표시 span
        const messageBox = document.getElementById('messageBox');

        let particles = []; // 모든 분자를 담을 배열
        let animationFrameId = null; // 애니메이션 프레임 ID
        let isPaused = false; // 일시정지 상태 플래그
        let membraneX; // 막의 x 좌표
        let pores = []; // 막의 구멍 위치 배열
        let speedMultiplier = 1.0; // 속도 배율 (초기값 1.0)

        // --- 분자 클래스 ---
        class Particle {
            constructor(x, y, radius, color, isSolute = false) {
                this.x = x; // x 좌표
                this.y = y; // y 좌표
                this.radius = radius; // 반지름
                this.color = color; // 색상
                this.isSolute = isSolute; // 용질 여부
                // 무작위 방향으로 초기 속도 설정 (방향 벡터)
                const angle = Math.random() * Math.PI * 2;
                this.vx_base = Math.cos(angle); // x 방향 단위 벡터
                this.vy_base = Math.sin(angle); // y 방향 단위 벡터
                this.vx = this.vx_base * BASE_PARTICLE_SPEED; // 현재 x 속도
                this.vy = this.vy_base * BASE_PARTICLE_SPEED; // 현재 y 속도
            }

            // 분자 그리기
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            // 분자 위치 업데이트 및 충돌 처리
            update(membraneX, pores, currentSpeedMultiplier) {
                // 1. 현재 속도 배율을 적용하여 위치 이동
                const currentSpeed = BASE_PARTICLE_SPEED * currentSpeedMultiplier;
                this.x += this.vx_base * currentSpeed;
                this.y += this.vy_base * currentSpeed;

                // 현재 속도 업데이트 (충돌 감지 등에 사용될 수 있음)
                this.vx = this.vx_base * currentSpeed;
                this.vy = this.vy_base * currentSpeed;


                // 2. 벽과의 충돌 처리
                let bounced = false;
                // 왼쪽 벽
                if (this.x - this.radius < 0) {
                    this.vx_base *= -1; // 방향 반전
                    this.x = this.radius + COLLISION_BUFFER;
                    bounced = true;
                }
                // 오른쪽 벽
                if (this.x + this.radius > canvas.width) {
                    this.vx_base *= -1; // 방향 반전
                    this.x = canvas.width - this.radius - COLLISION_BUFFER;
                    bounced = true;
                }
                // 위쪽 벽
                if (this.y - this.radius < 0) {
                    this.vy_base *= -1; // 방향 반전
                    this.y = this.radius + COLLISION_BUFFER;
                    bounced = true;
                }
                // 아래쪽 벽
                if (this.y + this.radius > canvas.height) {
                    this.vy_base *= -1; // 방향 반전
                    this.y = canvas.height - this.radius - COLLISION_BUFFER;
                    bounced = true;
                }

                // 3. 반투과성 막과의 충돌 처리
                const membraneLeft = membraneX - MEMBRANE_THICKNESS / 2;
                const membraneRight = membraneX + MEMBRANE_THICKNESS / 2;

                // 막과 충돌했는지 확인 (이동 방향 고려)
                let collisionSide = null;
                // 오른쪽으로 이동 중 막의 왼쪽 면과 충돌 가능성 확인
                if (this.vx > 0 && this.x + this.radius > membraneLeft && this.x - this.radius < membraneRight) {
                     // 정확한 충돌 지점 확인 (막의 왼쪽 면을 넘어섰는지)
                     if (this.x - this.radius < membraneLeft) {
                         collisionSide = 'left';
                     }
                }
                // 왼쪽으로 이동 중 막의 오른쪽 면과 충돌 가능성 확인
                else if (this.vx < 0 && this.x - this.radius < membraneRight && this.x + this.radius > membraneLeft) {
                     // 정확한 충돌 지점 확인 (막의 오른쪽 면을 넘어섰는지)
                     if (this.x + this.radius > membraneRight) {
                        collisionSide = 'right';
                     }
                }


                if (collisionSide) {
                    let canPass = false;
                    // 물 분자이고 구멍을 통과하는지 확인
                    if (!this.isSolute) {
                        for (const pore of pores) {
                            // 분자의 중심이 구멍의 y 범위 내에 있는지 확인
                            if (this.y > pore.y - pore.height / 2 && this.y < pore.y + pore.height / 2) {
                                canPass = true;
                                break;
                            }
                        }
                    }

                    // 통과하지 못하면 반사
                    if (!canPass) {
                        this.vx_base *= -1; // x 방향 반전
                        bounced = true;

                        // 위치 조정 로직
                        if (collisionSide === 'left') {
                            this.x = membraneLeft - this.radius - COLLISION_BUFFER;
                        } else {
                            this.x = membraneRight + this.radius + COLLISION_BUFFER;
                        }

                    } else {
                         // 통과하는 경우는 방향 변경 없이 그대로 진행
                    }
                }

                // 충돌 후 현재 속도 재계산 (방향이 바뀌었으므로)
                if (bounced) {
                    this.vx = this.vx_base * currentSpeed;
                    this.vy = this.vy_base * currentSpeed;
                }
            }
        }

        // --- 애니메이션 초기화 ---
        function init() {
            // 캔버스 크기 조절
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            membraneX = canvas.width / 2;
            particles = [];
            pores = [];

            // 막 구멍 생성
            for (let y = PORE_SPACING / 2; y < canvas.height; y += PORE_SPACING) {
                pores.push({ y: y, height: MEMBRANE_PORE_SIZE });
            }

            // 분자 생성
            createParticles(INITIAL_WATER_LEFT, 0, membraneX - MEMBRANE_THICKNESS / 2, WATER_RADIUS, WATER_COLOR, false);
            createParticles(INITIAL_SOLUTE_LEFT, 0, membraneX - MEMBRANE_THICKNESS / 2, SOLUTE_RADIUS, SOLUTE_COLOR, true);
            createParticles(INITIAL_WATER_RIGHT, membraneX + MEMBRANE_THICKNESS / 2, canvas.width, WATER_RADIUS, WATER_COLOR, false);
            createParticles(INITIAL_SOLUTE_RIGHT, membraneX + MEMBRANE_THICKNESS / 2, canvas.width, SOLUTE_RADIUS, SOLUTE_COLOR, true);

            // 속도 슬라이더 초기화
            speedMultiplier = parseFloat(speedSlider.value);
            speedValueSpan.textContent = `${speedMultiplier.toFixed(1)}x`;

            isPaused = true;
            draw();
            updateButtonStates();
            showMessage("시작 버튼을 눌러 애니메이션을 시작하세요.", 3000);
        }

        // --- 영역 내 무작위 위치에 분자 생성 함수 ---
        function createParticles(count, startX, endX, radius, color, isSolute) {
             for (let i = 0; i < count; i++) {
                let x, y, validPosition;
                let attempts = 0;
                do {
                    validPosition = true;
                    // 영역 내 무작위 위치 생성 (막 두께 고려)
                    x = Math.random() * (endX - startX - radius * 2 - (isSolute ? 0 : MEMBRANE_THICKNESS)) + startX + radius;
                    y = Math.random() * (canvas.height - radius * 2) + radius;

                    // 다른 분자와 겹치는지 확인
                    for (const p of particles) {
                        const dx = p.x - x;
                        const dy = p.y - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < p.radius + radius + COLLISION_BUFFER) {
                            validPosition = false;
                            break;
                        }
                    }
                    // 막 내부에 생성되지 않도록 확인 (Particle 생성 시 막을 고려하지 않으므로 여기서 체크)
                    const membraneLeft = membraneX - MEMBRANE_THICKNESS / 2;
                    const membraneRight = membraneX + MEMBRANE_THICKNESS / 2;
                    if (x + radius > membraneLeft && x - radius < membraneRight) {
                        validPosition = false;
                    }

                    attempts++;
                } while (!validPosition && attempts < 100);

                if (validPosition || attempts >= 100) {
                     particles.push(new Particle(x, y, radius, color, isSolute));
                     if(attempts >= 100 && !validPosition) console.warn("Overlap possible after 100 attempts.");
                } else {
                    // console.warn("Failed to place particle without overlap or inside membrane.");
                }
            }
        }

        // --- 그리기 함수 ---
        function draw() {
            // 캔버스 지우기
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 반투과성 막 그리기
            ctx.fillStyle = MEMBRANE_COLOR;
            let currentY = 0;
            for (const pore of pores) {
                const segmentHeight = pore.y - pore.height / 2 - currentY;
                if (segmentHeight > 0) {
                    ctx.fillRect(membraneX - MEMBRANE_THICKNESS / 2, currentY, MEMBRANE_THICKNESS, segmentHeight);
                }
                currentY = pore.y + pore.height / 2;
            }
            if (currentY < canvas.height) {
                 ctx.fillRect(membraneX - MEMBRANE_THICKNESS / 2, currentY, MEMBRANE_THICKNESS, canvas.height - currentY);
            }

            // 모든 분자 그리기
            particles.forEach(p => p.draw());
        }

        // --- 업데이트 함수 ---
        function update() {
            // 현재 속도 배율을 모든 분자 업데이트에 전달
            particles.forEach(p => p.update(membraneX, pores, speedMultiplier));
        }

        // --- 애니메이션 루프 ---
        function animate() {
            if (isPaused) return;

            update(); // 상태 업데이트
            draw(); // 그리기

            animationFrameId = requestAnimationFrame(animate);
        }

        // --- 메시지 표시 함수 ---
        function showMessage(message, duration = 2000) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (messageBox.timerId) {
                clearTimeout(messageBox.timerId);
            }
            messageBox.timerId = setTimeout(() => {
                messageBox.style.display = 'none';
                messageBox.timerId = null;
            }, duration);
        }

        // --- 버튼 상태 업데이트 함수 ---
        function updateButtonStates() {
            startButton.disabled = !isPaused;
            pauseButton.disabled = isPaused;
        }

        // --- 이벤트 리스너 ---
        startButton.addEventListener('click', () => {
            if (isPaused) {
                isPaused = false;
                animate();
                updateButtonStates();
                 showMessage("애니메이션 시작", 1500);
            }
        });

        pauseButton.addEventListener('click', () => {
            if (!isPaused) {
                isPaused = true;
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                updateButtonStates();
                 showMessage("애니메이션 일시정지", 1500);
            }
        });

        resetButton.addEventListener('click', () => {
            isPaused = true;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // 슬라이더 값도 초기화
            speedSlider.value = "1";
            init(); // init 함수 내에서 speedMultiplier 업데이트
             showMessage("초기 상태로 리셋", 1500);
        });

        // 속도 슬라이더 이벤트 리스너
        speedSlider.addEventListener('input', () => {
            speedMultiplier = parseFloat(speedSlider.value);
            speedValueSpan.textContent = `${speedMultiplier.toFixed(1)}x`;
            // 속도 변경 메시지 (선택적)
            // showMessage(`속도 ${speedMultiplier.toFixed(1)}x 로 변경`, 1000);
        });

        // 창 크기 변경 시
        window.addEventListener('resize', () => {
             isPaused = true;
             if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
             }
             // 슬라이더 값 유지 (또는 리셋 원하면 speedSlider.value = "1"; 추가)
             init();
             showMessage("창 크기 변경됨. 초기화되었습니다.", 2000);
        });

        // --- 초기 실행 ---
        init();

    </script>
</body>
</html>
